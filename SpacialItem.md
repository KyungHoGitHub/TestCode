# Spacial Item 
# 비트란?
비트란 0과 1 두 가지 값 만을 가질 수 있고 2진수 하나의 값을 저장할수 있는 가장 작은 단위의 데이터를 의미합니다.

![](Spacial%20Item/%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%84%8C%E1%85%B5%202023.%203.%2015.%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%206.40.jpeg)
-> 85의 이진수 표현

## 비트에서 홀수/짝수 표현 
-> 홀수 :비트의 가장에서 오른쪽자리의 값으로  1의 가지고 있는 값
-> 짝수 :비트의 가장에서 오른쪽자리의 값으로  0의 가지고 있는 값
- - - -


# Q1.홀수 인지 판별하는 함수를 생성해 보자
[예제코드 A]
```
public static boolean isOdd(int number) {
    return number % 2 != 0; // 2로 나누어서 나머지가 0 이 아닌 경우 					       		// 홀수 ture를 반환합니다 
}
```
-> A 코드의 경우 홀수를 판단하는 나머지의 기준으로 0을 지정

[예제코드 B]
```
public static boolean isOdd(int number) {
    return number % 2 == 1; // 2로 나누어서 나머지가 1 인경우  					       		// 홀수 ture를 반환합니다 
}
```
-> B 코드의 경우는 1을 지정

# B의 코드의 경우 음수값의 경우 원하는 결과를 얻을수 없다  
: B코드의 경우 음수의 경우 나머지 값또한 음수로 나오기 때문에 원하는 결과를 얻을수 없습니다 
음수를 홀수 짝수를 판단해야하는 경우 A 의 코드로 나머지의 기준을 0으로 정해야   합니다.

- - - -

# Q2. 연산을 더 빠르게 하는 방법으로 찾아보자
```
public static boolean isOddBit(int number) {
    return (number & 1) != 0; //비트 연산자 사용
}
```

 ![](Spacial%20Item/%E1%84%87%E1%85%B5%E1%84%90%E1%85%B3%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB.001.jpeg)


# ( n & 1 ) != 0 으로 대체 [비트연산자 사용] 사용
:해당 코드경우 비트연산자(&) 사용하여 5와 1의 비트의 마지막 자릿수를 비교하여 (true/false)를 판별하기 때문에 더욱 빠른 연산을 수행할 수있게 됩니다. 

## 비트연산자를 사용하면 더욱 빠른 연산이 가능한 이유
:비트 연산자는 2진수 연산에 최적화되어 있기 때문에 연산 속도가 빠르다는 장점이 있다. 
(PC 는 이진수 체계를 사용)

- - - -

# 📖 정리 
간단한 예제로 살펴 보았던 거와 같이  판별하는 기준에 있어서 조금 더 넓게 생각하여 기준을 정해서 원하지 않는 결과가 나오는  경우를 피해야 하고  더욱 효율적 방법을 고민해 보아야 합니다 .
 
마무리로 저는 이 예제를 통해 개발에 있어  여러가지 상황을 고려 해야 하고  나아가 더 효율적인 방법을 고려할 수 있도록 여러 개념과 기술에 더욱 적극적으로 학습하고 준비 되어 있어야 한다고 생각했습니다
  
